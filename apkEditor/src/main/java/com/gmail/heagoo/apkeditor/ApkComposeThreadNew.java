package com.gmail.heagoo.apkeditor;

import android.content.Context;
import android.util.Log;

import com.gmail.heagoo.apkeditor.base.BuildConfig;
import com.gmail.heagoo.apkeditor.base.R;
import com.gmail.heagoo.apkeditor.ce.IApkMaking;
import com.gmail.heagoo.apkeditor.ce.IDescriptionUpdate;
import com.gmail.heagoo.apkeditor.smali.ISmaliAssembleCallback;
import com.gmail.heagoo.apkeditor.util.SignHelper;
import com.gmail.heagoo.common.CommandRunner;
import com.gmail.heagoo.common.FileUtil;
import com.gmail.heagoo.common.ITaskCallback;
import com.gmail.heagoo.common.ITaskCallback.TaskStepInfo;
import com.gmail.heagoo.common.SDCard;

import java.io.File;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class ApkComposeThreadNew extends ComposeThread implements ISmaliAssembleCallback {

    private Context ctx;

    private String binRootPath;
    private String aaptPath;
    private String androidJarPath;
    private String decodedFilePath;
    private String targetApkPath; // Target APK path
    private String resourceApkPath; // if res modified, store the apk generated by aapt

    // Indicate succeed or not
    private boolean succeed;
    private String errMessage;

    // Record all the dex file replaces
    private Map<String, String> builtDexFiles = new HashMap<>();

    // Samli file modified or not
    private List<String> modifiedSmaliFolders = new ArrayList<>();

    private ITaskCallback taskCallback;

    private TaskStepInfo stepInfo;

    // Last time updating the smali assemble info
    private long lastUpdateAssembleTime = 0;

    // Flag to control run or not
    private boolean stopFlag = false;

    private boolean bSignApk;

    private IApkMaking extraMaker;

    /**
     * @param ctx             Context
     * @param decodedFilePath path store all the decoded files
     * @param apkPath         target apk path
     */
    public ApkComposeThreadNew(Context ctx, String decodedFilePath, String apkPath) {
        this.ctx = ctx;

        File fileDir = ctx.getFilesDir();
        String rootDirectory = fileDir.getAbsolutePath();
        this.binRootPath = rootDirectory + "/bin";
        this.aaptPath = binRootPath + "/aapt";
        this.androidJarPath = binRootPath + "/android.jar";
        // this.androidJarPath = SDCard.getRootDirectory() + "/android.jar";
        this.decodedFilePath = decodedFilePath;
        this.targetApkPath = apkPath;
        this.resourceApkPath = decodedFilePath + "/build/resource.apk";

        LOGGER.info("aaptPath: " + this.aaptPath);
        LOGGER.info("androidJarPath: " + this.androidJarPath);
        LOGGER.info("decodedFilePath: " + this.decodedFilePath);

        this.stepInfo = new TaskStepInfo();
    }

    // resReplaces contains non-xml replaces
    // resFileModified means res added/deleted, or xml changed
    @Override
    public void setModification(boolean strModified, boolean manifestModified,
                                boolean resFileModified, List<String> modifiedSmaliFolders,
                                Map<String, String> addedFiles, Map<String, String> replacedFiles,
                                Set<String> deletedFiles, Map<String, String> fileEntry2ZipEntry,
                                boolean bSignApk) {
        this.bSignApk = bSignApk;
    }

    @Override
    public void run() {
        long startTime = System.currentTimeMillis();
        // Make sure build directory is created
        File buildDir = new File(decodedFilePath + "/build");
        if (!buildDir.exists()) {
            buildDir.mkdir();
        }

        boolean rebuildResource = needRebuildResource();
        checkSmaliModification();

        this.stepInfo.stepTotal = 0;

        // Need to build resource
        if (rebuildResource) {
            stepInfo.stepTotal += 1;
        }
        // Merge
        stepInfo.stepTotal += 1;
        // For DEX assembling
        if (this.modifiedSmaliFolders != null && !this.modifiedSmaliFolders.isEmpty()) {
            stepInfo.stepTotal += this.modifiedSmaliFolders.size();
        }
        // Sign
        if (BuildConfig.WITH_SIGN && bSignApk) {
            this.stepInfo.stepTotal += 1;
        }
        // Cleanup
        this.stepInfo.stepTotal += 1;

        do {
            // XML/String/Manifest modified, requires re-compiling
            if (rebuildResource) {
                if (stopFlag) {
                    this.errMessage = "User request to stop";
                    break;
                }
                setNextStep(ctx.getString(R.string.compose));

                if (!prepare()) {
                    break;
                }

                // Compose resource and extract files
                if (stopFlag) {
                    this.errMessage = "User request to stop";
                    break;
                }
                if (!composeResource()) {
                    break;
                }
            }

            // Assemble DEX files
            builtDexFiles.clear();
            if (modifiedSmaliFolders != null && !modifiedSmaliFolders.isEmpty()) {
                boolean assembleError = false;
                for (String smaliFolder : modifiedSmaliFolders) {

                    String smaliPath = decodedFilePath + "/" + smaliFolder;
                    String dexName = getDexNameBySmaliFolder(smaliFolder);
                    setNextStep(ctx.getString(R.string.assemble_dex_file) + ": " + dexName);
                    try {
                        // Log.d("DEBUG", "Assemble " + smaliPath + " to " + dexName);
                        assembleSmali(smaliPath, dexName);
                    } catch (Throwable e) {
                        e.printStackTrace();
                        this.errMessage = e.getMessage();
                        assembleError = true;
                        break;
                    }

                    if (stopFlag) {
                        this.errMessage = "User request to stop";
                        assembleError = true;
                        break;
                    }
                }

                if (assembleError)
                    break;
            }

            // Merge
            if (stopFlag) {
                this.errMessage = "User request to stop";
                break;
            }
            setNextStep(ctx.getString(R.string.merge));

            try {
                long start = System.currentTimeMillis();
                mergeApk();
            } catch (Exception e) {
                e.printStackTrace();
                this.errMessage = ctx.getString(R.string.merge) + ": " + e.getMessage();
                break;
            }

            // Sign or not
            if (BuildConfig.WITH_SIGN && bSignApk) {
                if (stopFlag) {
                    this.errMessage = "User request to stop";
                    break;
                }
                setNextStep(ctx.getString(R.string.sign));
                if (!signApk()) {
                    break;
                }
            }

            // Clean up
            if (stopFlag) {
                this.errMessage = "User request to stop";
                break;
            }
            setNextStep(ctx.getString(R.string.cleanup));
            cleanup();

            // For free version, make sure it longer enough, so that ad could be loaded
            if (!BuildConfig.IS_PRO) {
                long curTime = System.currentTimeMillis();
                if (curTime - startTime < 7500) {
                    try {
                        Thread.sleep(7500 - (curTime - startTime));
                    } catch (InterruptedException ignored) {
                    }
                }
            }

            this.succeed = true;
        } while (false);

        if (!stopFlag) {
            if (succeed) {
                taskCallback.taskSucceed();
            } else {
                taskCallback.taskFailed(errMessage);
            }
        }
    }

    private long getLastModifyTime(File file) {
        if (file.exists()) {
            return file.lastModified();
        }
        // If file does not exist, then return 0
        return 0;
    }

    // Collect all modified smali folders
    private void checkSmaliModification() {
        File decodeDir = new File(decodedFilePath);
        File[] files = decodeDir.listFiles();
        for (File f : files) {
            if (!f.isDirectory()) {
                continue;
            }

            String dirName = f.getName();
            if (dirName.equals("smali") || dirName.startsWith("smali_")) {
                String dexName = getDexNameBySmaliFolder(dirName);
                long dexTime1 = getLastModifyTime(
                        new File(decodedFilePath + "/" + dexName));
                long dexTime2 = getLastModifyTime(
                        new File(decodedFilePath + "/build/" + dexName));
                long dexTime = (dexTime2 > dexTime1 ? dexTime2 : dexTime1);
                long smaliTime = FileUtil.recursiveModifiedTime(f);
                // Means smali code is modified
                if (smaliTime > dexTime) {
                    this.modifiedSmaliFolders.add(dirName);
                }
            }
        }
    }

    private String getDexNameBySmaliFolder(String smaliFolder) {
        if ("smali".equals(smaliFolder)) {
            return "classes.dex";
        }
        if (smaliFolder.startsWith("smali_")) {
            return smaliFolder.substring("smali_".length()) + ".dex";
        }
        return smaliFolder + ".dex";
    }

    private void setNextStep(String description) {
        stepInfo.stepIndex += 1;
        stepInfo.stepDescription = description;
        taskCallback.setTaskStepInfo(stepInfo);
    }

    // Assemble smali to DEX (build/classes.dex)
    private void assembleSmali(String smaliFilePath, String dexFileName)
            throws Throwable {
        File decodeDir = new File(decodedFilePath);
        File buildDir = new File(decodeDir, "build");
        if (!buildDir.exists()) {
            buildDir.mkdir();
        }

        File dexFile = new File(buildDir, dexFileName);
        String dexFilePath = dexFile.getPath();

        // Log.d("DEBUG", "assemble " + smaliFilePath + " to " + dexFilePath +
        // ", dexFileName=" + dexFileName);

        // Invoke DexEncoder.smali2Dex
        try {
            long start = System.currentTimeMillis();
            Class<?> obj_class = Class
                    .forName("com.gmail.heagoo.apkeditor.pro.DexEncoder");
            Method method = obj_class.getMethod("smali2Dex",
                    String.class, String.class, ISmaliAssembleCallback.class);
            method.invoke(null, smaliFilePath, dexFilePath, this);
            Log.i("DEBUG", "Encode time=" + (System.currentTimeMillis() - start));

            // Record built dex files
            this.builtDexFiles.put(dexFileName, dexFilePath);
        } catch (InvocationTargetException e) {
            throw e.getTargetException();
        }
    }

    private void cleanup() {
        // Delete all the decoded files
        // Do not delete the res directory any more, as the project must keep it
        CommandRunner cr = new CommandRunner();
//        cr.runCommand("rm -rf " + decodedFilePath + "/res", null, 10000);

        // Clean /sdcard/ApkEditor/tmp
        try {
            String tmpDir = SDCard.getRootDirectory() + "/ApkEditor/tmp";
            cr.runCommand("rm -rf " + tmpDir, null, 10000);
        } catch (Exception ignored) {
        }

        // Log.d("DEBUG", "decodedFilePath" + decodedFilePath);
    }

    private void mergeApk() {
        // Before merge, call the extra maker
        Map<String, String> extraReplaces = new HashMap<>();
        if (this.extraMaker != null) {
            try {
                extraMaker.prepareReplaces(ctx, resourceApkPath, extraReplaces,
                        // Note: currently not support description update
                        new IDescriptionUpdate() {
                            @Override
                            public void updateDescription(String strDesc) {
                            }
                        });
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        Map<String, String> filesToAdd = new HashMap<>();

        // Collect files need to be added

        File assetsDir = new File(decodedFilePath + "/assets");
        if (assetsDir.exists()) {
            collectFiles(filesToAdd, assetsDir, "assets/");
        }
        File libDir = new File(decodedFilePath + "/lib");
        if (libDir.exists()) {
            collectFiles(filesToAdd, libDir, "lib/");
        }
        File libsDir = new File(decodedFilePath + "/libs");
        if (libsDir.exists()) {
            collectFiles(filesToAdd, libsDir, "libs/");
        }
        File kotlinDir = new File(decodedFilePath + "/kotlin");
        if (kotlinDir.exists()) {
            collectFiles(filesToAdd, kotlinDir, "kotlin/");
        }
        File unknownDir = new File(decodedFilePath + "/unknown");
        if (unknownDir.exists()) {
            collectFiles(filesToAdd, unknownDir, "");
        }
        // DEX
        collectDexFiles(filesToAdd);

        // Transform to string
        StringBuilder sb = new StringBuilder();
        int addLen = 0;
        for (Map.Entry<String, String> entry : filesToAdd.entrySet()) {
            String key = entry.getKey();
            String value = entry.getValue();
            sb.append(key);
            sb.append('\n');
            sb.append(value);
            sb.append('\n');
            addLen += key.getBytes().length + value.getBytes().length + 2;
        }

        StringBuilder sb2 = new StringBuilder();
        int replaceLen = 0;
        for (Map.Entry<String, String> entry : extraReplaces.entrySet()) {
            String key = entry.getKey();
            String value = entry.getValue();
            sb2.append(key);
            sb2.append('\n');
            sb2.append(value);
            sb2.append('\n');
            replaceLen += key.getBytes().length + value.getBytes().length + 2;
        }

        MainActivity.md(targetApkPath, resourceApkPath, sb.toString(), addLen, "", 0, sb2.toString(), replaceLen);
    }

    // Collect all the dex files should be added to resource.apk
    private void collectDexFiles(Map<String, String> filesToAdd) {
        filesToAdd.putAll(this.builtDexFiles);

        File decodeDir = new File(decodedFilePath);
        File[] files = decodeDir.listFiles();
        for (File f : files) {
            String name = f.getName();
            if (f.isFile() && name.endsWith(".dex")) {
                if (!this.builtDexFiles.containsKey(name)) {
                    // Check the same dex name in build directory whether exist
                    File dex = new File(decodedFilePath + "/build/" + name);
                    if (dex.isFile() && dex.exists()) {
                        filesToAdd.put(name, dex.getPath());
                    } else {
                        filesToAdd.put(name, f.getPath());
                    }
                }
            }
        }
    }

    private void collectFiles(Map<String, String> relPath2AbsPath, File dir, String relPath) {
        File[] files = dir.listFiles();
        for (File f : files) {
            if (f.isFile()) {
                relPath2AbsPath.put(relPath + f.getName(), f.getPath());
            } else if (f.isDirectory()) {
                collectFiles(relPath2AbsPath, f, relPath + f.getName() + "/");
            }
        }
    }

    private boolean needRebuildResource() {
        boolean buildResource = true;

        // To check if need to build the resource
        File apkFile = new File(resourceApkPath);
        if (apkFile.isFile() && apkFile.exists()) {
            long resModifyTime = FileUtil.recursiveModifiedTime(new File[]{
                    new File(decodedFilePath + "/res"),
                    new File(decodedFilePath + "/AndroidManifest.xml")});
            long apkTime = apkFile.lastModified();
            if (apkTime > resModifyTime) {
                buildResource = false;
            }
        }

        return buildResource;
    }

    private boolean signApk() {
        String signedPath = targetApkPath + ".signed";
        try {
            Map<String, String> emptyMap = new HashMap<>();
            Set<String> emptySet = new HashSet<>();
            SignHelper.sign(ctx, targetApkPath, signedPath, emptyMap, emptyMap, emptySet);

            // Rename the signed the apk to target apk name
            File targetFile = new File(targetApkPath);
            targetFile.delete();
            new File(signedPath).renameTo(targetFile);

            return true;
        } catch (Exception e) {
            String strHeader = ctx.getResources().getString(R.string.sign_error);
            this.errMessage = strHeader + e.getMessage();
        }

        return false;
    }

    private boolean composeResource() {
        boolean noVersionVectorOption = ApkComposeThread.getNoVersionVectorOption(ctx, aaptPath);

        List<String> paramList = new ArrayList<>();
        paramList.add(aaptPath);
        paramList.add("package");
        paramList.add("-f");
        paramList.add("-I");
        paramList.add(androidJarPath);
        paramList.add("-S");
        paramList.add(decodedFilePath + "/res");
        paramList.add("-M");
        paramList.add(decodedFilePath + "/AndroidManifest.xml");
        paramList.add("-F");
        paramList.add(resourceApkPath);
        if (noVersionVectorOption) {
            paramList.add("--no-version-vectors");
        }

        long startTime = System.currentTimeMillis();
        CommandRunner cr = new CommandRunner();
        boolean ret = cr.runCommand(paramList.toArray(new String[paramList.size()]),
                null, null, 300 * 1000, true);
        //Log.e("DEBUG", "aapt Time: " + (System.currentTimeMillis() - startTime) / 1000.0 + " seconds");

        LOGGER.info("stdout: " + cr.getStdOut() + ", ret=" + ret);
        if (!ret) {
            LOGGER.info("stderr: " + cr.getStdError());
            this.errMessage = cr.getStdError();
            return false;
        }


        return true;
    }

//    private boolean composeResource() {
//        boolean noVersionVectorOption = ApkComposeThread.getNoVersionVectorOption(ctx, aaptPath);
//        List<String> cmd = new ArrayList<>();
//        cmd.add(aaptPath);
//
//
//        File resDir = new File(decodedFilePath + "/res");
//
//        File resourcesZip = null;
//        if (resDir != null)
//        {
//            File buildDir = new File(resDir.getParent(), "build");
//            resourcesZip = new File(buildDir, "resources.zip");
//        }
//        if (resDir != null && !resourcesZip.exists()) {
//            List<String> cmdt = new ArrayList<>();
//
//
//            cmdt.add(aaptPath);
//            cmdt.add("compile");
//            cmdt.add("--dir");
//            cmdt.add(resDir.getAbsolutePath());
//            cmdt.add("--legacy");
//
//            File buildDir = new File(resDir.getParent(), "build");
//            resourcesZip = new File(buildDir, "resources.zip");
//
//            cmdt.add("-o");
//            cmdt.add(resourcesZip.getAbsolutePath());
//
//
//            long startTime = System.currentTimeMillis();
//            CommandRunner cr = new CommandRunner();
//            boolean ret = cr.runCommand(cmdt.toArray(new String[cmdt.size()]),
//                    null, null, 300 * 1000, true);
//
//            LOGGER.info("stdout: " + cr.getStdOut() + ", ret=" + ret);
//            if (!ret) {
//                LOGGER.info("stderr: " + cr.getStdError());
//                this.errMessage = cr.getStdError();
//                return false;
//            }
//
//        }
//        File manifest = new File(decodedFilePath + "/AndroidManifest.xml");
//
//        if (manifest == null)
//        {
//            return false;
//        }
//
//        cmd.add("link");
//        cmd.add("-o");
//        cmd.add(targetApkPath);
//        cmd.add("--no-auto-version");
//        cmd.add("--no-version-vectors");
//        cmd.add("--no-version-transitions");
//        cmd.add("--no-resource-deduping");
//
//         boolean resourcesAreCompressed = false;
//        if (!resourcesAreCompressed)
//        {
//            cmd.add("-0");
//            cmd.add("arsc");
//        }
//
//        cmd.add("-I");
//        cmd.add(androidJarPath);
//        cmd.add("--manifest");
//        cmd.add(manifest.getAbsolutePath());
//
//        File assetDir = new File(resDir.getParent(), "assets");
//        if (assetDir != null)
//        {
//            cmd.add("-A");
//            cmd.add(assetDir.getAbsolutePath());
//        }
////        File rawDir = new File(resourceApkPath);
////        if (rawDir != null)
////        {
////            cmd.add("-R");
////            cmd.add(resourceApkPath);
////        }
//
//        if (resourcesZip != null)
//        {
//            cmd.add("-o");
//            cmd.add(resourcesZip.getAbsolutePath());
//        }
//
//        long startTime = System.currentTimeMillis();
//        CommandRunner cr = new CommandRunner();
//        boolean ret = cr.runCommand(cmd.toArray(new String[cmd.size()]),
//                null, null, 300 * 1000, true);
//
//        LOGGER.info("stdout: " + cr.getStdOut() + ", ret=" + ret);
//        if (!ret) {
//            LOGGER.info("stderr: " + cr.getStdError());
//            this.errMessage = cr.getStdError();
//            return false;
//        }
//
//        return true;
//    }

    // This method will extract the necessary files
    private boolean prepare() {
        try {
            return ApkComposeThread.prepare(ctx, aaptPath, binRootPath);
        } catch (Exception e) {
            this.errMessage = e.getMessage();
            return false;
        }
    }

    @Override
    public void setTaskCallback(ITaskCallback taskCallback) {
        this.taskCallback = taskCallback;
    }

    @Override
    public void updateAssembledFiles(int assembledFiles, int totalFiles) {
        long curTime = System.currentTimeMillis();
        if (curTime > this.lastUpdateAssembleTime + 500) {
            String fmt = ctx.getString(R.string.assemble_dex_detail);
            stepInfo.stepDescription = String.format(fmt, assembledFiles,
                    totalFiles);
            taskCallback.setTaskStepInfo(stepInfo);
        }
    }

    @Override
    public void stopRunning() {
        this.stopFlag = true;
        this.interrupt();
    }

    @Override
    public void setExtraMaker(IApkMaking extraMaker) {
        this.extraMaker = extraMaker;
    }

    public String getErrMessage() {
        return errMessage;
    }
}
